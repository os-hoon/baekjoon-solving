## 백준 1966
- 이 문제는 큐(LinkedList)를 선언 및 초기화 할 때 Integer, String형이 아닌, int[]와 같은 배열형으로도 가능하다는 사실을 몰라서 아주 어렵게 느껴졌습니다.
- 처음에 중요도를 알려주는 큐와 처음 인덱스 위치를 알려주는 큐 2개를 생성해서 구해보려고 했습니다.
- 하지만 LinkedList에서만 get을 통해서 해당 인덱스 위치의 값을 알 수 있다는 것을 알게 되어서 LinkedList를 생성해서 큐처럼 사용했습니다.
- 두 개의 큐로 문제를 풀려고 하니 좀 복잡하다고 느껴져 한 개의 큐를 int[] 형으로 만들어서 문제를 해결했습니다.
- 큐에 처음 인덱스 위치와 중요도 값을 입력받은 순서대로 넣어줍니다.
- 큐가 비어질 때까지 while을 통해 실행해주고, 큐의 첫번째 값을 comp 배열에 넣어주고 큐에 남은 부분들과 비교해줍니다.
- 만약 맨 앞의 comp 값보다 큐 안에 더 큰 중요도 값이 있다면 comp 값을 포함해 더 큰 중요도 값 앞까지 모두 앞에서 뒤로 옮겨주고 state를 false로 바꿔주고 반복문을 중단 해줍니다.
- 비교하는 반복문이 끝난 후 state가 true라면 큐 안에 comp 값보다 중요도가 큰 값이 없는 것이므로 카운트해줍니다.
- state가 true인 상황에서 만약 comp의 초기 인덱스값이 M과 같다면 문제에서 찾는 값이므로, 그 때 카운트를 출력하고 다음 케이스로 넘어갑니다.