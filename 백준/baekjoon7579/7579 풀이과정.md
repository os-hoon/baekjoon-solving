## 백준 7579
- 문제에서 주어진 메모리 바이트 M을 사용해 열은 0~M까지 행은 1~N까지 각각 비용에 대한 좌표에서 메모리의 최댓값을 DP배열에 저장해주며 해결해나갔습니다.
- 이 문제의 핵심은 최소의 비용을 M이상의 메모리 바이트에서 계산해야하는 것이기 때문에 모든 메모리에 대해 탐색을 했을 때 값이 처음으로 M이상인 비용을 찾으면 되는 것입니다.
- 모든 메모리 바이트를 조합했을 때 나올 수 있는 비용의 최댓값까지 다 구해봐야하므로 allcost 변수에 주어진 비용들의 총합을 저장해줍니다.
- DP 배열을 구할 때 N과 allcost에 대해서 반복문을 돌려주며, 다음과 같이 2가지 경우로 나눠서 생각해주면 됩니다.
  - arr[i][1] > j (현재 배열의 비용이 j 보다 클 때): dp[i][j]에 dp[i-1][j] 즉 이전 행 값을 넣어줍니다.
  - arr[i][0] <= j (현재 배열의 비용이 j 보다 작거나 같을 때): dp[i-1][j]와 arr[i][0] (현재 배열의 메모리 바이트값) + dp[i-1][j - arr[i][1]] (여기서 열은 현재 최대 비용 j에서 현재 배열의 비용을 뺀 값) 중 더 큰 값을 dp[i][j]에 넣어줍니다.
- 그런데 이 문제에서 최소 비용을 찾는 것이기 때문에 dp[N][j] 를 구했을 때 M보다 같거나 큰 경우가 나오면 그게 원하는 정답이므로 출력해주고 종료해주면 됩니다.