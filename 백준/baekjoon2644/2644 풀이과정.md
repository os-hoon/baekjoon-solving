## 백준 2644
- 1 부터 n 번호의 사람들 중에 가장 번호가 작은 사람을 시작으로 서로 다른 두 사람의 촌수를 계산하려고 했는데, 그렇게 하면 생각해줘야할 경우의 수가 너무 많아져서 복잡했습니다.
- 그래서 고민해보니 그냥 촌수를 계산해야 하는 서로 다른 두 사람의 번호 중 하나를 dfs의 시작 노드로 설정하고 다른 번호 하나가 나올때 까지 카운트를 세며 탐색해주면 촌수를 쉽게 구할 수 있다는 사실을 알게됐습니다.
- 저는 서로 다른 두 사람의 번호 중 앞쪽의 번호를 start, 뒷쪽의 번호를 end에 저장하고 start를 기준으로 dfs 탐색을 했습니다.
- dfs 탐색을 할 때 반복문을 실행하며 arr[V][i] == 1 && !check[i] 이 조건을 만족할 때 다음 노드로 이동 할 수 있으므로 카운트를 한 번 세어주고 다음 노드로 이동한 재귀함수 호출이 끝나면 이전 노드로 돌아와야하므로 다시 카운트를 한 번 줄여줍니다.
- 이렇게 탐색을 하다가 현재 노드가 end 번호와 같아지면 그 때 카운트를 ans 배열에 저장해줍니다.
  -  만약 두 번호가 연결되어 있지 않아 친척 관계가 전혀 없는 경우에는 기본 적으로 ans 배열에 저장되어 있는 -1을 출력해주면 됩니다.