## 백준 1931
- 저는 이 문제를 시작 시간을 기준으로 정렬을 해서 풀었습니다.
- 그런데 79%에서 계속 틀렸다고 뜨길래, 뭐가 문제인지 잘 모르겠어서 반례를 찾아봤는데, 총 2개의 회의를 입력받는데 1 2를 먼저 입력받고 1 1을 받는 경우가 있었습니다.
- 저는 return a[0] - b[0] 만 사용해서 람다식으로 정렬해도 1 2, 1 1 로 입력되면 1 1, 1 2로 정렬 된다고 착각해서 반례에서 계속 막혔다는걸 알게되었습니다.
- if(a[0] == b[0])
  return a[1] - b[1]; 조건까지 추가해서 정렬해줍니다.
- N이 1이면 최대 회의 개수가 1개이므로 1을 출력해줍니다.
- N이 1이 아닌 경우, cur 변수를 생성하고 배열 첫번째 인덱스의 종료값으로 초기화 해줍니다.
- 반복문에서 다음 회의 시작시간이 이전 회의 종료시간보다 작고, 다음 회의 종료시간이 이전 회의 종료시간보다 작으면 카운트는 세지 않고 cur 변수를 다음 회의 종료시간으로 갱신해주고, 다음 회의 시작 시간이 이전 회의 종료시간보다 크거나 같으면 카운트해주고 cur을 다음 회의 종료시간으로 갱신해줍니다.